\section{Storia e ruolo dei proof assistant}
I proof assistant sono software di supporto alla fomalizzazione e alla prova di concetti logico-matematici. 

La nascita dei primi proof assistant è da datarsi alla fine degli anni '60 con il progetto Automath, che per primo utilizzò l'isomorfismo di Curry-Howard (\ref{natden}) nel tentativo di sviluppare un sistema per la definizione accurata e la verifica della matematica. Tali sforzi sono conversi in più sofisticate teorie logiche ed in moderni sisitemi come Coq, Isabelle, Agda e Lean, nonchè nell'ampliamento delle corrispettive librerie.

Tali strumenti hanno permesso il raggiungimento di importanti risultati negli ultimi decenni: nel 2005 Georges Gonthier ha provato formalmente la correttezza del teorema dei quattro colori utilizzando il proof assistant Coq \cite{Gonthier2005ACP}, nel 2006 è stata pubblicata una prova del teorema dei numeri primi verificata tramite Isabelle/HOL \cite{Avigad2007} e nel 2014 è stato completato il progetto di verifica tramite Isabelle/HOL della congettura di Keplero \cite{hales2017}. Quest'ultimo risultato è particolarmente esemplificativo del ruolo che i computer possono ricoprire nel moderno panorama matematico: la congettura, riguradante l'impacchettamento delle sfere nello spazio euclideo tridimensionale, venne formulata da Keplero nel 1611 e una soluzione parziale venne proposta nel 1831 da Gauss. La complessità della congettura le valse un posto nella lista dei ventitrè problemi irrisolti della matematica stilata da Hilbert nel 1900, come parte del diciottesimo problema. Nel corso del novecento fu provato che la congettura poteva essere risolta tramite il calcolo di un numero finito, seppur molto grande, di casi. La dimostrazione presentata da Hales nel 1998 faceva un intensivo utilizzo del computer per risolvere più di diecimila problemi di programmazione lineare. La correttezza della prova si basava però sulla fiducia nella correttezza dei calcoli svolti dal computer. Hales, per rimuovere i dubbi rimanenti, decise nel 2003 di dare vita al progetto \emph{”Flyspeck”} con l'intento di formalizzare la prova utilizzando il proof assistant Isabelle/HOL. Il progetto, teminato nel 2014, ha avuto esito positivo e la prova della congettura è oggi comunemente accettata come corretta, più di 400 anni dopo la sua iniziale formulazione. 

Nel febbraio del 2022 OpenAI ha pubblicato le specifiche \cite{openAILean} di una rete neurale capace di risolvere, tra gli altri, due problemi delle olimpiadi internazionali di matematica utilizzando il proof assistant Lean. Il risultato si inserisce in un più ampio sforzo di introduzione delle intelligenze artificiali nell'ambito logico-matematico, impossibile senza estesi sistemi di definizione e verifica utilizzabili da macchine.

Al di là della matematica \emph{tradizionale}, la verifica formale tramite proof assistant può essere estesa agli ambiti scientifici più disparati, tra cui, relativamente all'informatica, alla verifica della correttezza di hardware, software e protocolli di rete. Nella pratica, la verifica di un sistema software o di un sistema hardware, necessita della descrizione accurata in termini logico-matematici dell'entità del sistema e la dimostrazione di proprietà o della correttezza del sistema non è altro che una forma di dimostrazione di teoremi.

I proof-assistant costituiscono uno dei due modi con i quali un computer può supportare la dimostrazione di affermazioni matematiche: mediante la ricerca automatizzata della dimostrazione, o tramite la verifica della correttezza di una dimostrazione data. SAT solver (software che determinano se una data formula booleana è soddisfacibile o meno) e SMT solver (una generalizzazione dei SAT solver a fomule che includono numeri reali, interi, strutture dati ecc. entro una data teoria) si concentrano sul primo punto, ma la complessità dei relativi problemi (SAT è NP-completo) e le conseguenti risorse necessarie possono condurre a sistemi limitati la cui correttezza non sempre è garantita, mentre i proof-assistant si concentrato sugli aspetti di verifica della dimostrazione, facendo spesso affidamento su un piccolo kernel fidato e prove verificabili indipendentemente: la maggior parte di questi sistemi genera \emph{proof objects} completamente dettagliati che possono essere forniti ad altri sistemi per una verifica terza della loro correttezza. L'obiettivo dichiarato è di sorpassare la "catena di fiducia" sulla quale la matematica tradizionalmente si fonda e fornire dimostrazioni verificate costruibili in modo pienamente dettagliato a partire da un insieme ristretto di assiomi.

\section{Lean}
Lean è un linguaggio di programmazione funzionale basato sulla teoria dei tipi dipendenti, la cui logica fondazionale si presta all'utilizzo come proof assistant. Il progetto è nato da Leonardo de Moura presso Microsoft Research nel 2013 e nel tempo ha accolto un numero crescente di professionisti ed entusiasti che contribuiscono al costante ampliamento della sua libreria e allo sviluppo del linguaggio. Obiettivo del progetto è colmare il divario tra la ricerca automatizzata e la verifica delle dimostrazioni, sviluppando un sistema capace di automatizzare le dimostrazioni fornendone al contempo una descrizione assiomaticamente accurata. Lean si basa su un kernel molto ristretto \cite{deMoura2015}, le cui componenti principali sono descritte in questa parte del testo. Il progetto è relativamente recente, ma capace di ricevere attenzioni per via dell'elevata attività condotta da parte della community nel contesto della formalizzazione della teoria matematica, con una libreria che al 31 dicembre 2021 contava 72.847 teoremi, di cui più di un terzo aggiunti nel corso dell'ultimo anno, spazianti dall'algebra alla geometria, dalla topologia all'analisi, dalla combinatoria alla computabilità.
Viene qui utilizzata la versione 3 del linguaggio: una versione più recente è disponibile \cite{10.1007/978-3-030-79876-5_37} ma al momento della scrittura di questo documento il processo di trasposizione della libreria matematica (utile ma comunque non strettamente necessaria ai fini del progetto) da parte della comunità risulta essere incompleto.

\subsection{Confronto con altri \emph{proof-assistant}}
Il sistema di tipi di Lean è basato sul \emph{Calculus of Inductive Constructions} \cite{coquand:inria-00076024}, che è altresì alla base del proof-assistant Coq. Nonostante le fondazioni logiche dei due siano simili, esistono alcune differenze, tra cui il fatto che in Lean l'universo \mintinline{Lean}|Prop| delle proposizioni è proof-irrelevant, ovvero due termini il cui tipo rappresenti la medesima proposizione sono considerati equivalenti anche se la loro struttura è differente, o in altre parole, ciò che \emph{interessa} di una proposizione è il fatto che sia dimostrabile o meno e non la struttura della prova.

Agda è basato su una teoria simile a quella di Lean, ma è fortemente influenzato dall'implementazione in Haskell sottostante. Le prove sono scritte interamente con una struttura funzionale in cui chiave è il ricorso al pattern-matching e alle chiamate ricorsive. L'automazione è estremamente ridotta e non esistono tattici, che al contrario sono applicati in modo estensivo in Lean.