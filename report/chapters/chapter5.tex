Questa parte presenta un'applicazione concreta del proof-assistant Lean per la fomalizzazione e la verifica di semplici proprietà di un linguaggio di programmazione imperativo. Il lavoro è fortemente ispirato al testo di Nipkow e Klein \cite{concrete}, in cui il processo di formalizzazione e verifica è supportato dal proof-assistant Isabelle/HOL.

Un linguaggio di programmazione imperativo si basa sui concetti di stato e comando. Lo stato è una rappresentazione astratta della memoria tramite l'assegnamento di un valore a ciascuna variabile, un comando (o programma) rappresenta una sequenza di trasformazioni sullo stato. Un programma esegue a partire da uno stato iniziale e produce, successivamente ad una sequenza di trasformazioni, uno stato finale.

Un linguaggio può essere descritto a livello di sintassi e di semantica. La sintassi descrive le combinazioni di simboli che sono considerate valide al fine della definizione di un programma, ma non ne descrive il \emph{significato}, ovvero l'effetto computazionale di tali strutture sintattiche, che è invece fornito dalla sua semantica. Esistono diversi modi di definire la semantica di un linguaggio di programmazione, nel seguente documento vengono mostrate due formulazioni operazionali, intese come sequenze di operazioni sullo stato.

Un linguaggio può essere arricchito con un sistema di tipi, ovvero un sistema logico di complessità arbitraria utile a predirre staticamente certe proprietà desiderate di un programma, quali l'assenza di una certa classe di errori o specifiche politiche circa il flusso di informazioni. In un sistema di tipo statico la valutazione avviene a tempo di compilazione, garantendo che la proprietà richiesta sia rispettata in qualsiasi esecuzione del codice. I sistemi definiti in questo documento sono facilmente traducibili in algoritmi decisori: ogni costrutto sintattico presenta esattamente una regola e applica ricorsivamente le regole di giudizio ai sottotermini del comando. Dato che un programma si compone di un numero finito di comandi e per ogni comando esiste una sola regola applicabile, ogni esecuzione dell'algoritmo termina. 