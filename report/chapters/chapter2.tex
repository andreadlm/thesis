Questo capitolo introduce i concetti fondamentali alla base del linguaggio di programmazione Lean, ponendo l'accento sul suo sistema di tipo.

\section{Lambda-calcolo}
\begin{comment}
Il $\lambda$-calcolo nasce come conseguenza al tentativo di fomalizzazione della nozione di algoritmo nella prima metà del '900. Uno degli obiettivi del programma di Hilbert era quello di risolvere l'\emph{Entscheidungsproblem} (problema della decisione), ovvero fornire una procedura calcolabile (un algoritmo) per determinare la verità o meno di qualsiasi proposizione formulata nel linguaggio della logica del prim'ordine. Fino a quel momento, la nozione di algoritmo non era mai stata formalizzata con precisione. La dimostrazione fornita nel 1930 da Godel circa l'incompletezza dell'aritmetica minò le basi del programma di Hilbert e condusse alla necessità di produrre una definizione formale del concetto di algoritmo: il concetto intuitivo poteva essere sufficiente per fornire algoritmi per alcuni compiti, ma per provare che che una procedura calcolabile per la risoluzione dell'\emph{Entscheidungsproblem} non poteva esistere era necessario avere una definizione chiara.
\end{comment}

Il $\lambda$-calcolo è un calcolo equazionale introdotto da Alonzo Church nel 1936 per definire le funzioni e il loro calcolo. Consiste in un sistema formale per la definizione di funzioni e in regole per la loro valutazione (riduzione). Il $\lambda$-calcolo fornisce una notazione estremamente compatta per le funzioni, contenendo solamente tre costrutti: variabili, astrazioni e applicazioni. Le funzioni sono considerate come oggetti \emph{di prima classe}, ovvero, una funzione può apparire come argomento o risultato di un'altra funzione.

Si definisce termine nel $\lambda$-calcolo qualsiasi stringa ben formata ottenibile a partire dalla seguente grammatica:
\begin{gather*}
    M,N ::= x \;|\; \lambda x.M \;|\; N M \\
    \text{con Var} = \{x, y, z, \dots\}\;\text{un insieme infinito di variabili} 
\end{gather*}

A livello terminologico, diciamo che $(\lambda x.M)$ è un'astrazione con argomento $x$ e corpo $M$, mentre $M N$ rappresenta l'applicazione della funzione $M$ all'argomento $N$.
La sintassi per le $\lambda$-astrazioni in Lean è la seguente:
\begin{code}{Lean}
λ(x : α), M
\end{code}
Lean utilizza una forma di $\lambda$-calcolo tipato più complessa di quella qui presentata, dove ad ogni oggetto viene associato un tipo specifico. Ai fini dell'esempio questo aspetto può essere tralasciato.

Le variabili possono comparire libere o legate in un termine. Informalmente, un'occorrenza di $x$ in $M$ è legata se compare in un sottotermine della forma $\lambda x.N$ di $M$, mentre è libera altrimenti.

\begin{comment}
L'insieme delle variabili libere in un termine $M$ è definito induttivamente sulla struttura di $M$ come segue:
$$\text{\emph{fv}}(x) = x \quad \text{\emph{fv}}(\lambda x.M) = \text{\emph{fv}}(M)\setminus\{x\} \quad \text{\emph{fv}}(M N) = \text{\emph{fv}}(M) \cup \text{\emph{fv}}(N)$$
\end{comment}

$M\{y/x\}$ rappresenta il termine ottenuto sostituendo ogni occorrenza libera di $x$ in $M$ con $y$, evitando possibili catture tramite opportune rinominazioni delle variabili legate.

Una forma base di equivalenza tra termini è rappresentata dal concetto di $\alpha$-conver-sione, che cattura l'idea secondo cui il significato di un funzione sia indipendente dal nome dell'argomento. Ad esempio, i termini $\lambda x.x$ e $\lambda y.y$ sono equivalenti e rappresentano entrambi la funzione identità. Formalmente
$$y \notin \text{\emph{fv}}(M) \implies \lambda x.M \Leftrightarrow_{\alpha} \lambda y.M\{y/x\}$$

L'idea di applicazione di una funzione è espressa dal concetto di $\beta$-riduzione: intuitivamente, applicare una funzione $\lambda x.M$ ad un argomento $N$ corrisponde a valutare il corpo $M$ della funzione in cui ogni occorrenza libera di $x$ sia stata sostituita da $N$. Formalmente, la $\beta$-riduzione è la relazione tra $\lambda$-espressioni tale che:
\begin{align*}
    & (\lambda x.M)\,N \rightarrow_{\beta} M\{N/x\} \\
    & M \rightarrow_{\beta} M' \implies M N \rightarrow_{\beta} M' N \\
    & M \rightarrow_{\beta} M' \implies N M \rightarrow_{\beta} N M' \\
    & M \rightarrow_{\beta} M' \implies \lambda x.M \rightarrow_{\beta} \lambda x.M'
\end{align*}

Un termine si dice in forma normale se non è ulteriormente riducibile. La forma normale, se esiste, è unica. Una processo di riduzione potrebbe non terminare mai: ad esempio il termine $(\lambda x. x\,x) (\lambda x. x\,x)$ non possiede una forma normale.

In Lean è possibile chiedere di ridurre un termine in forma normale tramite il comando \begin{mintinline}{Lean} #reduce \end{mintinline}:
\begin{code}{Lean}
#reduce (λ(x : α)(y : α), y) z w
-- w
\end{code}
Due termini che si riducano al medesimo termine sono considerati \emph{equivalenti per definizione} dal kernel di Lean e quest'ultimo fa del suo meglio per riconoscere tale equivalenza. Allo stesso modo, Lean riconosce come equivalenti due termini che siano $\alpha$-convertibili l'uno nell'altro.

A titolo di esempio si osservi come il $\lambda$-calcolo sia sufficientemente flessibile da permettere un'opportuna rappresentazione dei numeri naturali. Un numero $n$ può essere rappresentato come una funzione che accetta una funzione $s$ ed un valore $z$ ed applica $s$ a $z$ $n$ volte (il numero 3 è rappresentato, nella codifica proposta da Church, dal termine $\lambda s.\lambda z. s(s(s(z)))$). In tal modo diviene facile definire funzioni che sommino o moltiplichino tra loro numeri naturali. Tale rappresentazione sfrutta l'idea di Peano di costruire l'insieme $\mathbb{N}$ a partire dallo zero e dalla funzione successore: ogni numero è successore del precedente, tranne lo zero che non è successore di alcun numero e appartiene assiomaticamente all'insieme. La stessa idea (ma formalizzata in modo differente) sta alla base della definizione dei numeri naturali tramite tipi induttivi utilizzata da Lean (\ref{tind}).

Church propose il $\lambda$-calcolo come definizione rigorosa del concetto di algoritmo e dimostrò l'esistenza di un problema la cui soluzione non poteva essere definita mediante esso: quello di verificare se un termine possedesse o meno una forma normale, l'equivalente in termini di $\lambda$-calcolo dell'indecidibilità problema della fermata descritto da Turing. In effetti, le due nozioni di algoritmo proposte da Turing e Church sono tra loro equivalenti, un risultato oggi noto come Tesi di Church-Turing. Pertanto, il $\lambda$-calcolo può essere considerato il più piccolo linguaggio di programmazione esistente: qualsiasi algoritmo umanamente calcolabile è definibile sotto forma di $\lambda$-termini. In tal senso, un singolo passo di $\beta$-riduzione può essere considerato un passo di calcolo e la forma normale del termine il risultato dell'elaborazione. Questa interpretazione computazionale è ciò che rende Lean utilizzabile come un linguaggio di programmazione.

\section{Tipi semplici} \label{tsemp}
Il $\lambda$-calcolo può essere esteso tramite un sistema di tipi che permetta di evitare termini privi di significato, restringendone la sintassi alle sole espressioni che consideriamo significative entro il sistema. Il primo sistema di tipo introdotto da Church prevedeva un solo costruttore ($\rightarrow$) per definire tipi funzionali \cite{10.2307/2266170}. Ne viene qui presentata una versione con estesa al costruttore di tipi prodotto ($\times$).

Lean permette di dichiarare costanti e di determinarne il tipo tramite i comandi  \begin{mintinline}{Lean} constant \end{mintinline} e \begin{mintinline}{Lean} #check \end{mintinline}. Ogni termine entro il sistema possiede un tipo ben determinato:
\begin{code}{Lean}
constant n : ℕ
constants b₁ b₂ : bool

#check 1 -- ℕ
#check (&&) -- bool → bool → bool
#check n + 2 -- ℕ
#check b₁ && b₂ -- bool
\end{code}

Se $\alpha$ e $\beta$ rappresentano due tipi (come \begin{mintinline}
{Lean} nat \end{mintinline}, \begin{mintinline}
{Lean} bool \end{mintinline}, \begin{mintinline}
{Lean} char \end{mintinline} ...), $\alpha \rightarrow \beta$ rappresenta il tipo delle funzioni che accettano un argomento di tipo $\alpha$ e producono un risultato di tipo $\beta$, mentre $\alpha \times \beta$ rappresenta il tipo del prodotto cartesiano, ovvero il tipo delle coppie il cui primo elemento ha tipo $\alpha$ e il secondo elemento ha tipo $\beta$:
\begin{code}{Lean}
constants α β : Type
constant m : α
constant n : β
constant f : α → β
constant g : (α × β) → β

#check m -- α
#check f -- α → β
#check g -- (α × β) → β
#check f m -- β
#check (m, n) -- α × β
#check g (m, n) -- β
\end{code}
Le regole di tipo sono fornite in coppie: una regola di introduzione definisce come costrutire un termine di un determinato tipo e una regola di eliminazione definisce come utilizzarlo.

Le regole di introduzione ed eliminazione per il tipo funzionale rappresentano la definizione di una $\lambda$-astrazione e la sua applicazione: se assunta una variabile $x : \alpha$ viene costruito un termine $N : \beta$, allora si può definire la lambda astrazione $\lambda x.N$ di tipo $\alpha \rightarrow \beta$:
\begin{code}{Lean}
constant N : β
#check λ (x : α), N -- α → β
\end{code}
Analogamente, dato un termine $L : \alpha \rightarrow \beta$ e un termine $M : \alpha$ si può costrutire il termine $L\; M : \beta$. In Lean:
\begin{code}{Lean}
constant L : α → β
constant M : α
#check L M -- β
\end{code}

La regola di introduzione per il tipo prodotto, afferma che dati due termini $M : \alpha$ e $N : \beta$ sia possibile costrutire il termine coppia $( M, N): \alpha \times \beta$:
\begin{code}{Lean}
constant M : α
constant N : β
#check (M, N) -- α × β
\end{code}
La regola di eliminazione per il tipo prodotto è una semplice proiezione: dato un termine $L : \alpha \times \beta$ si può costrutire un termine $L_1 : \alpha$ e, analogamente, un termine $L_2 : \beta$:
\begin{code}{Lean}
constant L : α × β
#check L.1 -- α
#check L.2 -- β 
\end{code}

Lean permette la definizione di $\lambda$-astrazioni tramite il comando \begin{mintinline}{Lean} def \end{mintinline}. Ogni definizione è preceduta da un nome e dal tipo desiderato. Il \emph{type-checker} verifica che il termine che segue possieda il tipo specificato. Una semplice funzione che scambi gli elementi di una coppia di interi viene definita nel seguente modo:
\begin{code}{Lean}
def swap : (ℕ × ℕ) → (ℕ × ℕ) := 
   λ (z : ℕ × ℕ), (z.snd, z.fst)
\end{code}

\begin{comment}
Riprendendo quanto affermato ad inizio capitolo, le proposizioni sono identificate da particolari tipi, per cui l'attività matematica di provare un teorema corrisponde alla costruzione di un particolare oggetto, un $\lambda$-termine, abitante del tipo che rappresenta la proposizione. La valutazione di un programma, o riduzione del $\lambda$-termine, corrisponde alla semplificazione della prova: si consideri un termine che costruisce una coppia di tipo $\alpha \times \beta$ a partire da $a : \alpha$ e $b : \beta$ prima costruendo una coppia di tipo $\beta \times \alpha$ e poi invertendone gli elementi con la funzione definita sopra. La riduzione del termine mostra un modo più semplice per ottenere lo stesso risultato:
\begin{code}{Lean}
constant a : α
constant b : β

#check (λ (z : β × α), (z.snd, z.fst)) (b, a)
-- α × β
#reduce (λ (z : β × α), (z.snd, z.fst)) (b, a)
-- (a, b)
\end{code}

Nel capitolo \ref{tdep} viene mostrata una estensione del sistema di tipo utile a rappresentare i concetti di quantificazione universale ed esistenziale.
\end{comment}

\section{Tipi dipendenti} \label{tdep}
Il sistema di tipi di Lean è più avanzato rispetto alla semplice formulazione proposta alla sezione \ref{tsemp}, permettendo al linguaggio di essere espressivo rispetto ad un'ampia gamma di concetti logico-matematici. In particolare, Lean si basa su una versione della teoria dei tipi dipendenti nota come \emph{Calculus of Constructions} \cite{coquand:inria-00076024}, estesa con tipi induttivi.

\subsection{Universi e famiglie}
Un universo è un tipo i cui elementi sono a loro volta dei tipi. Quando diciamo che $\alpha$ è un tipo, intendiamo che è abitante di un particolare universo. Gli universi in Lean sono organizzati in modo gerarchico a partire da \mintinline{Lean}|Type| (\mintinline{Lean}|Type 0|) e crescono all'infinito:
\begin{code}{Lean}
#check Type -- Type 1
#check Type 1 -- Type 2
#check Type 2 -- Type 3
\end{code}
dove \begin{mintinline}{Lean} Type \end{mintinline} corrisponde all'universo dei tipi \emph{ordinari} o \emph{semplici}, come  \begin{mintinline}{Lean} nat \end{mintinline}, \begin{mintinline}{Lean} bool \end{mintinline} e \begin{mintinline}{Lean} string \end{mintinline}:
\begin{code}{Lean}
#check nat -- Type
#check bool -- Type
#check string -- Type
\end{code}

Per modellare collezioni di tipi che spaziano su un dato tipo $\alpha$, vengono definite funzioni il cui codominio è un dato universo, ovvero funzioni che producono tipi. Queste funzioni sono dette famiglie di tipi (o tipi dipendenti). Un tipo dipendente è un tipo che dipende su un parametro. Un esempio di tipo dipendente è \begin{mintinline}{Lean} fin \end{mintinline}, la famiglia degli insiemi finiti:
\begin{code}{Lean}
#check fin -- ℕ → Type
\end{code}
Non è possibile assegnare ad un oggetto il tipo $fin$: $fin$ teoricamente non è un tipo, ma una famiglia di tipi dipendente su un parametro o, in un altro senso, una funzione che produce tipi:
\begin{code}{Lean}
constant err : fin -- ERROR!
#check fin 2 -- Type
constant ok : fin 2
\end{code}
$fin\;2$ è un tipo (in particolare, un abitante di \begin{mintinline}{Lean} Type \end{mintinline}): il tipo cui abitanti sono tutti e soli gli insiemi finiti composti da 2 elementi.

Similmente, \begin{mintinline}{Lean} list \end{mintinline} rappresenta la famiglia dei tipi lista e il parametro su cui dipende è un tipo:
\begin{code}{Lean}
#check list -- Type u → Type u
\end{code}
\mintinline{Lean}|list| è una funzione che dato un tipo appartente ad un universo di livello \mintinline{Lean}|u|, produce un tipo che appartiene al medesimo universo. In tal modo possiamo modellare liste di tipi qualsiasi avendo un tipo preciso per ciascuna di esse:
\begin{code}{Lean}
#check list ℕ -- Type
#check list bool -- Type
\end{code}

\subsection{Tipi funzione e prodotto dipendente}
Nella teoria dei tipi dipendenti è possibile definire una versione più generale del tipo funzionale che sfrutti i tipi dipendenti nella propria definzione, chiamato Pi-type o tipo funzionale dipendente. Gli abitanti di un Pi-type sono funzioni il cui tipo del codominio può variare in relazione all'elemento del dominio cui la funzione è applicata:
\begin{code}{Lean}
constant α : Type
constant β : α → Type
#check Π (x : α), (β x) -- Type
\end{code}
$\Pi_{(x:\,\alpha)}, (\beta\,x)$ rappresenta il tipo delle funzioni $f$ con la proprietà che, per ogni $x:\,\alpha$, $f\;x$ è un abitante di $\beta\,x$, ovvero, il tipo del valore ritornato da $f$ dipende dall'input ricevuto.

Il tipo di una funzione \emph{polimorfa} che inserisca un elemento in testa ad una lista è così definito:
\begin{code}{Lean}
constant cons : Π (α : Type), α → list α → list α
#check cons ℕ -- ℕ → list ℕ → list ℕ
\end{code}
dove gli abitanti del tipo $\Pi_{(\alpha:\,\text{Type})}, \alpha \rightarrow list\,\alpha \rightarrow list\,\alpha$ sono funzioni $f$ con la proprietà che, per ogni tipo $\alpha$, $f\,\alpha$ ha tipo $\alpha\rightarrow list\,\alpha\rightarrow list\,\alpha$. Ad esempio, \mintinline{Lean}|cons ℕ| è una funzione che accetta un intero e una lista di interi e produce una lista di interi.

L'espressione $\Pi_{(x : \alpha)}, \beta$ ha senso per ogni tipo $\beta$ e non solamente per tipi dipendenti. Se $\beta$ non è un tipo dipendente il tipo $\Pi_{(x : \alpha)}, \beta$ è equivalente a $\alpha \rightarrow \beta$. Lean tratta i tipi funzionali come casi particolari di tipi funzionali dipendenti quando $\beta$ non è un tipo dipendente:
\begin{code}{Lean}
constant β : Type
#check Π (x : α), β -- α → β
\end{code}

Come il Pi-type generalizza il concetto di tipo funzionale, il Sigma-tipe o tipo prodotto dipendente generalizza il concetto di tipo prodotto:
\begin{code}{Lean}
constant α : Type
constant β : α → Type
#check Σ (x : α), β x -- Type
\end{code}
dove il tipo del secondo elemento della coppia può dipendere dal primo elemento della coppia stessa.

In alcuni casi, il tipo su cui la funzione/prodotto dipende può essere reso implicito lasciando Lean libero di inferirlo dal contesto: i termini portano con se molta informazione e parte di quest'informazione può essere inferita automaticamente dal sistema:
\begin{code}{Lean}
-- Versione esplicita
constant cons₁ : Π (α : Type), α → list α → list α
constant l₁ : list ℕ
constant n₁ : ℕ
#check cons₁ ℕ n₁ l₁

-- Versione implicita
constant cons₂ : Π {α : Type}, α → list α → list α
constant l₂ : list ℕ
constant n₂ : ℕ
#check cons₂ n₂ l₂
\end{code}
nel secondo caso, non è necessario \emph{specializzare} la funzione esplicitamente.

\section{Tipi induttivi} \label{tind}
In Lean ogni tipo al di fuori degli universi e ogni costruttore di tipo al di fuori del Pi-type è definito induttivamente. Fornire una definizione per un tipo consiste nel mostrare come i termini del tipo possano essere costruiti. La definizione di un tipo induttivo si compone pertanto di un numero finito di funzioni costruttori, dove gli argomenti di un costruttore per il tipo $h$ possono comprendere oggetti di tipo $h$. Ogni tipo induttivo definisce delle regole di introduzione (i costruttori) e delle regole di eliminazione (principio di \emph{ricorsione} sul tipo). Ad esempio, il tipo \begin{mintinline}{Lean} nat \end{mintinline} dei numeri naturali è definito come segue:
\begin{code}{Lean}
inductive nat : Type
| zero : nat
| succ : nat → nat

#check nat.zero -- nat (0)
#check nat.succ(nat.succ nat.zero) -- nat (2)
\end{code}
dove vengono specificati l'universo di appartenenza del tipo (\begin{mintinline}{Lean} Type \end{mintinline}) e i due costruttori (o regole di introduzione) \begin{mintinline}{Lean} zero \end{mintinline} e \begin{mintinline}{Lean} succ \end{mintinline}. I numeri naturali sono definiti alla Peano, con lo zero che appartiene assiomaticamente all'insieme e ogni numero diverso da zero definito come successore del precedente.
La regola di eliminazione, in inglese \emph{recursor}, definisce il modo con il quale è possibile sfruttare il tipo. Il \emph{recursor} per \begin{mintinline}{Lean} nat \end{mintinline} viene usato per definire funzioni $\Pi_{(n :\,\text{nat})}, C\,n$ per una qualche famiglia (eventualmente costante) di tipi $C$.
Per \emph{costruire} un termine $C\,n$ codominio di una funzione $f$ il \emph{recursor} necessita di $C$ (in Lean può essere lasciato implicito e inferito dal contesto), $n : \text{nat}$ elemento su cui viene applicato il principio di ricorsione, $f\,0 : C\,0$, $f\,n : C\,n$ nel caso in cui $n = \text{succ}\,n'$  assumendo il risultato della chiamata ricorsiva $f\,n' : C\,n'$:
\begin{code}{Lean}
#check nat.rec_on
-- Π {C : ℕ → Type*} (n : ℕ), C 0 → (Π (n : ℕ), C n → C n.succ) → C n
\end{code}
La funzione somma tra due numeri naturali è definibile nel seguente modo:
\begin{code}{Lean}
-- Versione esplicita
def add : ℕ → ℕ → ℕ :=
  λ (n m : ℕ), @nat.rec_on (λ (x : ℕ), ℕ) n m (λ (n add_m_n' : ℕ), succ add_m_n')

-- Versione implicita
def add : ℕ → ℕ → ℕ :=
  λ (n m : ℕ), nat.rec_on n m (λ (n add_m_n' : ℕ), succ add_m_n')

#reduce add 5 6 -- 11
\end{code}
Lo stesso risultato è ottenibile tramite pattern-matching:
\begin{code}{Lean}
def add : ℕ → ℕ → ℕ
| 0        m := m
| (succ n) m := succ (m + n)
\end{code}
in questo caso l'\emph{equation compiler} di Lean compila la definizione producendo una $\lambda$-astrazione simile a quelle mostrate sopra. Le definizioni tramite pattern-matching non fanno parte del kernel di Lean.

Generalizzando, la definizione di una funzione su un tipo induttivo richiede di specificare un caso per costruttore e permette di sfruttare le chiamate ricorsive agli argomenti del costruttore stesso.

\begin{comment}
Ad esempio, il tipo \begin{mintinline}{Lean} and \end{mintinline} è definito come segue:
\begin{code}{Lean}
inductive and {p : Prop} {q : Prop} : Prop
| intro : p → q → and 
\end{code}
\end{comment}

\subsection{Famiglie induttive}
Una famiglia induttiva generalizza il concetto di tipo induttivo, definendo simultaneamente un'intera famiglia di tipi indicizzata. Ad esempio, la famiglia dei tipi vettore indicizzata sulla dimesione del vettore stesso \mintinline{Lean}|vector| è defnita come segue:
\begin{code}{Lean}
inductive vector (α : Type u) : nat → Type u
| nil {}                              : vector zero
| cons {n : ℕ} (a : α) (v : vector n) : vector (succ n)
\end{code}
dove viene fornita simultaneamente la definizione dei tipi \mintinline{Lean}|vector 1|, \mintinline{Lean}|vector 2|, \mintinline{Lean}|vector 3| ...

Ogni costruttore può istanziare un diverso elemento della famiglia e sfruttare un termine di un particolare elemento della famiglia per costruire un termine di un altro elemento, come nel caso di \mintinline{Lean}|cons|, che accetta un temine di tipo \mintinline{Lean}|vector n| e produce un termine di tipo \mintinline{Lean}|vector (succ n)|.

\begin{comment}
Una prova per induzione segue il medesimo principio, semplicemente il codominio $C\,n$ è un abitante di \begin{mintinline}{Lean} Prop \end{mintinline} e l'ipotesi induttiva è rappresentata dalla chiamata ricorsiva:

Le parole chiave \begin{mintinline}{Lean} theorem \end{mintinline} e \begin{mintinline}{Lean} lemma \end{mintinline} sono versioni alternative di \begin{mintinline}{Lean} def \end{mintinline} nel caso di proposizioni.

La Tabella 2.1 può essere estesa con i nuovi legami introdotti:
\begin{center}
\begin{tabular}{ | c | c | } 
  \hline
  \textbf{Logica} & \textbf{Teoria dei tipi} \\ 
  \hline
  Induzione & Ricorsione \\ 
  \hline
  Ipotesi induttiva & Chiamata ricorsiva \\ 
  \hline
\end{tabular}
\end{center}
\end{comment}