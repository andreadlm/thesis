\label{cap7}
Il seguente capitolo definisce un semplice sistema di tipi per prevenire operazioni che coinvolgano tipologie di dati che consideriamo incompatibili e ne prova la proprietà di safety. A tal scopo, viene definita un'estensione di IMP che ammetta sia valori interi che reali e l'annessa semantica.

\section{IMP, esteso}
La versione di IMP considerata in questo capitolo estende il dominio dei valori ai numeri reali:
\begin{minted}{Lean}
inductive val : Type
| Iv : ℕ → val
| Rv : ℝ → val
\end{minted}
La sintassi per le espressioni espressioni aritmetiche ammette due tipologie di costanti (intere e reali):
\begin{minted}{Lean}
inductive aexp : Type
| Ic   : ℕ → aexp
| Rc   : ℝ → aexp
| V    : vname → aexp
| Plus : aexp → aexp → aexp
\end{minted}

La principale differenza tra la versione base di IMP e quella qui presentata risiede nella definizione della semantica per le espressioni.
Supposto che interi e reali siano due categorie di dati tra di loro incompatibili, la sintassi per le espressioni aritmetiche permette di scrivere espressioni prive di significato, la cui valutazione fallisce. La funzione di valutazione diviene parziale: a tale formulazione è preferita la definizione di un predicato induttivo che introduce le sole regole di valutazione per i casi validi e lascia indefiniti gli altri. In tal modo una valutazione è derivabile nel sistema solo se l'espressione è semanticamente corretta. Il predicato \mintinline{Lean}|taval| associa ad un'espressione e ad uno stato di valutazione il valore corrispondente:
\begin{minted}{Lean}
inductive taval : aexp → pstate → val → Prop
| tavalI {i : ℕ} {s : pstate} : 
  taval (Ic i) s (Iv i)

| tavalR {r : ℝ} {s : pstate} : 
  taval (Rc r) s (Rv r)

| tavalV {x : vname} {s : pstate} :
  taval (V x) s (s x)

| tavalPI {a₁ a₂ : aexp} {s : pstate} {i₁ i₂ : ℕ} :
  taval a₁ s (Iv i₁) →
  taval a₂ s (Iv i₂) →
  taval (Plus a₁ a₂) s (Iv (i₁ + i₂))

| tavalPR {a₁ a₂ : aexp} {s : pstate} {r₁ r₂ : ℝ} :
  taval a₁ s (Rv r₁) →
  taval a₂ s (Rv r₂) →
  taval (Plus a₁ a₂) s (Rv (r₁ + r₂))
\end{minted}
Analogamente, nelle espressione booleane non vengono permessi confronti tra valori interi e reali. Il predicato \mintinline{Lean}|tbval| segue lo stesso principio adottato per \mintinline{Lean}|taval|. Gli unici casi significativi sono i seguenti:
\begin{minted}{Lean}
| tbvalLI {a₁ a₂ : aexp} {s : pstate} {i₁ i₂ : ℕ} :
  taval a₁ s (Iv i₁) →
  taval a₂ s (Iv i₂) →
  tbval (Less a₁ a₂) s (i₁ < i₂)

| tbvalLR {a₁ a₂ : aexp} {s : pstate} {r₁ r₂ : ℝ} :
  taval a₁ s (Rv r₁) →
  taval a₂ s (Rv r₂) →
  tbval (Less a₁ a₂) s (r₁ < r₂)
\end{minted}

Per quanto riguarda la semantica dei comandi, una formulazione small-step meglio si presta alla rappresentazione di computazioni che possono produrre errori: se c'è un errore, la riduzione si blocca in uno stato non finale senza alcuna regola che permetta di proseguire oltre. La semantica per questa versione di IMP è molto simile a quella già definita, con la differenza che ogniqualvolta sia richiesta la valutazione di un'espressione, questa deve essere derivabile entro i sistemi definiti precedentemente:
\begin{minted}{Lean}
inductive small_step : conf → conf → Prop
| Assign  {s : pstate} {x : vname} {a : aexp} {v : val}:
  taval a s v →
  small_step (x ::= a, s) (SKIP, s[x ↦ v])

| Seq1 {c₂ : com} {s : pstate} :
  small_step (SKIP;;c₂, s) (c₂, s)

| Seq2 {c₁ c₁' c₂ : com} {s s' : pstate} :
  small_step (c₁, s) (c₁', s') →
  small_step (c₁ ;; c₂, s) (c₁' ;; c₂, s')

| IfTrue {b : bexp} {s : pstate} {c₁ c₂ : com}:
  tbval b s tt →
  small_step (IF b THEN c₁ ELSE c₂, s) (c₁, s)

| IfFalse {b : bexp} {s : pstate} {c₁ c₂ : com}:
  tbval b s ff →
  small_step (IF b THEN c₁ ELSE c₂, s) (c₂, s)

| While {b : bexp} {c : com} {s : pstate} :
  small_step (WHILE b DO c, s) (IF b THEN (c ;; WHILE b DO c) ELSE SKIP, s)
\end{minted}
si noti come la semantica non ha nozione del concetto di tipo: valutazione della correttezza di tipo ed esecuzione del programma risiedono su due piani differenti.

Ad esempio, il comando
\begin{minted}{Lean}
WHILE Less (V "x") (Rc 2.5) DO 
  "x" ::= Plus (V "x") (Rc 1.0)
\end{minted}
è sintatticamente corretto, ma nel caso in cui lo stato associ ad \mintinline{Lean}|x| un valore intero, l'esecuzione si blocca in corrispondenza della valutazione della guardia del ciclo, se invece lo stato associa a \mintinline{Lean}|x| un valore reale, l'esecuzione prosegue senza errori. Al costo di tenere traccia dei dei tipi immutabili associati a ciascuna variabile, un sistema di tipi permette di evitare questo genere di problemi, garantendo a tempo di compilazione l'assenza di errori in qualsiasi esecuzione del programma.

\section{Sistema di tipi}
Viene introdotto un sistema di tipi che permetta di decidere a tempo di compilazione l'assenza di errori nella valutazione delle espressioni, assicurando che un programma ben tipato non si blocchi durante l'esecuzione. Il sistema presenta due tipi, corrispondenti alle due categorie di valori introdotti per le espressioni aritmetiche:
\begin{minted}{Lean}
inductive ty : Type
| Ity
| Rty
\end{minted}

Un contesto tiene traccia dei tipi dichiarati per ogni variabile, permettendo solo combinazioni compatibili nelle espressioni:
\begin{minted}{Lean}
abbreviation tyenv := vname → ty
\end{minted}

Il sistema di tipi permette di derivare giudizi della forma:
\begin{itemize}
    \item \mintinline{Lean}|Γ ⊢ₐ a : τ| a significare che un'espressione aritmetica \mintinline{Lean}|a| ha tipo \mintinline{Lean}|τ| nel contesto \mintinline{Lean}|Γ|
    \item \mintinline{Lean}|Γ ⊢₆ b| a significare che un'espressione booleana \mintinline{Lean}|b| è ben tipata nel contesto \mintinline{Lean}|Γ|
    \item \mintinline{Lean}|Γ ⊢. c| a significare che un comando \mintinline{Lean}|c| è ben tipato nel contesto \mintinline{Lean}|Γ|
\end{itemize}
Le regole per \mintinline{Lean}|aexp| sono definite in Lean come segue:
\begin{minted}{Lean}
inductive atyping : tyenv → aexp → ty → Prop
| atypeI {Γ : tyenv} {i : ℕ} :
  atyping Γ (Ic i) Ity

| atypeR {Γ : tyenv} {r : ℝ} :
  atyping Γ (Rc r) Rty

| atypeV {Γ : tyenv} {x : vname} :
  atyping Γ (V x) (Γ x)

| atypeP {Γ : tyenv} {a₁ a₂ : aexp} {τ : ty} :
  atyping Γ a₁ τ →
  atyping Γ a₂ τ →
  atyping Γ (Plus a₁ a₂) τ
\end{minted}
Analogamente, le regole per \mintinline{Lean}|bexp|:
\begin{minted}{Lean}
inductive btyping : tyenv → bexp → Prop
| btypeC {Γ : tyenv} {bv : bool} :
  btyping Γ (Bc bv)

| btypeN {Γ : tyenv} {b : bexp} :
  btyping Γ b →
  btyping Γ (Not b)

| btypeA {Γ : tyenv} {b₁ b₂ : bexp} :
  btyping Γ b₁ →
  btyping Γ b₂ →
  btyping Γ (And b₁ b₂)

| btypeL {Γ : tyenv} {a₁ a₂ : aexp} {τ : ty} :
  atyping Γ a₁ τ →
  atyping Γ a₂ τ →
  btyping Γ (Less a₁ a₂)
\end{minted}
Infine, le regole per \mintinline{Lean}|com| seguono lo stesso principio di applicazione ricorsiva ai sotto-termini della sintassi. L'unico caso interessante è il seguente:
\begin{minted}{Lean}
| ctypeAssign {Γ : tyenv} {a : aexp} {x : vname} :
  (Γ ⊢ₐ a : (Γ x)) →
  ctyping Γ (x ::= a)
\end{minted}
dove è richiesta concordanza tra tipo dichiarato per la variabile e tipo valutato per l'espressione.
\section{Correttezza}
Per provare la correttezza del sistema di tipi è necessario introdurre alcune definizioni ausiliarie. La funzione \mintinline{Lean}|type| mette in corrispondenza valori e tipi, definendo quali valori sono compatibili con ciascun tipo:
\begin{minted}{Lean}
def type : val → ty
| (Iv i) := Ity
| (Rv r) := Rty
\end{minted}
un valore è compatibile con un tipo se può essere assegnato ad una variabile del dato tipo. Uno stato \mintinline{Lean}|s| si dice ben tipato nel contesto \mintinline{Lean}|Γ| se associa ad ogni variabile un valore compatibile con il suo tipo:
\begin{minted}{Lean}
notation Γ ` ⊢₅ ` s := ∀ (y : vname), type (s y) = Γ y
\end{minted}

Il teorema di correttezza afferma che dato un comando \mintinline{Lean}|c| ben tipato in uno stato \mintinline{Lean}|s| ben tipato, o l'esecuzione di \mintinline{Lean}|c| è terminata, o è possibile compiere un ulteriore passo di calcolo:
\begin{minted}{Lean}
theorem type_soundness {Γ : tyenv} {c c' : com} 
                       {s s' : pstate} {cs'' : conf} :
  (c, s)↝*(c', s') → 
  (Γ ⊢. c) → 
  (Γ ⊢₅ s) → 
  ¬(c' = SKIP) → 
  ∃ (cs'' : conf), (c', s')↝cs''
\end{minted}
La prova necessita della dimostrazione di alcuni lemmi intermedi.

Il lemma di preservazione per espressioni aritmetiche afferma che il valore associato alla valutazione di un'espressione aritmetica ben tipata in uno stato ben tipato è compatibile con il tipo associato all'espressione:
\begin{minted}{Lean}
lemma preservation_aexp {Γ : tyenv} {a : aexp} {τ : ty} 
                        {s : pstate} {v : val} : 
  (Γ ⊢ₐ a : τ) → taval a s v → (Γ ⊢₅ s) → type v = τ
\end{minted}
La dimostrazione è una semplice induzione su \mintinline{Lean}|Γ ⊢ₐ a : τ|.

Il lemma del progresso per espressioni aritmetiche dimostra la correttezza del sistema di tipi per le espressioni aritmetiche. Ogni valutazione di un'espressione ben tipata termina producendo un valore:
\begin{minted}{Lean}
lemma progress_aexp {Γ : tyenv} {a : aexp} {τ : ty} 
                    {s : pstate} :
  (Γ ⊢ₐ a : τ) → (Γ ⊢₅ s) → ∃ (v : val), taval a s v
\end{minted}
La dimostrazione è condotta per induzione su \mintinline{Lean}|Γ ⊢ₐ a : τ|. Chiave è il ricorso al lemma di preservazione per il caso \mintinline{Lean}|atypeP|.
Due lemmi ausiliari vengono introdotti per invertire la funzione \mintinline{Lean}|type|:
\begin{minted}{Lean}
lemma extract_Ity {v : val} :
  (type v = Ity) → ∃ i, v = (Iv i) 
\end{minted}
e analogamente per \mintinline{Lean}|Rty|.

Il lemma di preservazione per i comandi afferma che un comando si mantiene ben tipato successivamente all'esecuzione di un passo di calcolo:
\begin{minted}{Lean}
lemma preservation_com {Γ : tyenv} {c c' : com} 
                       {s s' : pstate } :
  (Γ ⊢. c) → (c, s)↝(c', s') → (Γ ⊢. c')
\end{minted}
La dimostrazione è una semplice induzione su \mintinline{Lean}|Γ ⊢. c|.

Analogo è il teorema del progresso per espressioni booleane. La valutazione di un'espressione ben tipata in uno stato compatibile al contesto termina sempre:
\begin{minted}{Lean}
lemma progress_bexp {Γ : tyenv} {b : bexp} {s : pstate} :
  (Γ ⊢₆ b) → (Γ ⊢₅ s) → ∃ (v : bool), tbval b s v
\end{minted}
La dimostrazione è condotta per induzione su \mintinline{Lean}|Γ ⊢₆ b|. L'unico caso non banale è \mintinline{Lean}|btypeL|: la presenza nelle premesse di due espressioni aritmetiche richiede il ricorso ai lemmi di preservazione e progresso per espressioni aritmetiche.

Il lemma di preservazione dello stato afferma che uno stato si mantiene ben tipato successivamente all'esecuzione di un comando ben tipato:
\begin{minted}{Lean}
 lemma preservation_state {Γ : tyenv} {c c' : com} 
                          {s s' : pstate } :
  (Γ ⊢. c) → (Γ ⊢₅ s) → (c, s)↝(c', s') → (Γ ⊢₅ s')
\end{minted}
la dimostrazione procede per induzione su \mintinline{Lean}|Γ ⊢. c|. L'unico caso che richieda un'anlisi non banale è il giudizio per il comando di assegnazione \mintinline{Lean}|ctypeAssign|: la dimostrazione per \mintinline{Lean}|Γ ⊢₅ s[x ↦ v]| necessita di distinguere, assunto un \mintinline{Lean}|y| qualsiasi, i due casi in cui \mintinline{Lean}|s[x ↦ v]| sia applicato a \mintinline{Lean}|y = x| o a \mintinline{Lean}|y ≠ x|. Nel primo caso, la dimostrazione del passaggio \mintinline{Lean}|s[x ↦ v] y = v| è ottenuta per semplificazione (\mintinline{Lean}|simp|) dall'evidenza \mintinline{Lean}|y = x| tramite il lemma intermedio
\begin{minted}{Lean}
@[simp] 
lemma apply_state_update_pos {x y : vname} {s : pstate} 
                             {v : val} :
  (y = x) → s[x ↦ v] y = v
\end{minted}
Analogamente, il secondo caso necessita di dimostrare \mintinline{Lean}|s[x ↦ v] y = s y|per semplificazione a partire da \mintinline{Lean}|y ≠ x| e dal lemma
\begin{minted}{Lean}
@[simp] 
lemma apply_state_update_neg {x y : vname} {s : pstate} 
                             {v : val} :
  ¬(y = x) → s[x ↦ v] y = (s y)
\end{minted}

Il lemma del progresso per i comandi richiede di prendere in considerazione la possibilità che il programma sia terminato. Altrimenti, una configurazione ben tipata può procedere di un passo di calcolo senza generare errori:
\begin{minted}{Lean}
lemma progress_com {Γ : tyenv} {c : com} { s: pstate} :
  (Γ ⊢. c) → 
  (Γ ⊢₅ s) → 
  ¬(c = SKIP) → 
  ∃ (cs' : conf), (c, s)↝cs'
\end{minted}
Infine, il teorema di correttezza segue dai lemmi di preservazione e progresso per comandi e stati.

